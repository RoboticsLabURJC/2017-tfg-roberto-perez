\chapter{Introducción}\label{cap.introduccion}
En este primer capítulo voy a tratar de explicar el contexto de las bases tecnológicas en las que se apoya este proyecto, que son principalmente las tecnologías web y la robótica. Para empezar hablare del contexto de las tecnologías web y como de importantes son en la sociedad actual, para continuar explicando su arquitectura y las tecnologías más importantes. Continuare hablando sobre el estado actual de la robótica y la gran expansión de la misma en nuestros días. Para finalizar este capitulo, introduciré en Jderobot y en los proyectos previos que combinan tecnologías web con componentes robóticos.
\section{Tecnologías de desarrollo web}
\subsection{Introducción}
Desde que en el año 1992, Tim Berners-Lee ideara y desarrollara las primeras herramientas para facilitar compartir información entre los científicos del CERN desde cualquier parte del mundo, dando lugar a la posteriormente llamada World Wide Web o como se conoce coloquialmente la web, ha sufrido una gran evolución, consiguiendo que la sociedad actual no se pueda entender sin la existencia de la misma. Sin embargo, pese a la gran evolución, el propósito de la web no ha cambiado, es decir que acceder a la información sea lo más fácil posible, si lo ha hecho la manera en que la utilizamos. La aparición de aplicaciones web como las redes sociales, los servicio de streaming o los comercios electrónicos, han supuesto un impulso importante en el uso de la web y, por consiguiente, la necesidad de idear nuevas herramientas que faciliten el desarrollo de webs.

\subsection{Arquitectura de una aplicación web}
Desde su creación, el modelo para que un sitio o aplicación web funcione no ha variado.
\begin{itemize}
	\item Cliente: Realiza las peticiones de recursos a diferentes servidores web a través de un localizador uniforme de recursos (URL). Generalmente, la función de cliente la realizada un navegador.
	\item Servidor: Almacena la información de la aplicación web y sirve los contenidos acorde a las peticiones realizadas por el navegador.
	\item Http: Es el protocolo creado por Bernens-Lee que permite el intercambio de información entre el cliente y el servidor.
\end{itemize}
\begin{figure}[H]
  \begin{center}
    \includegraphics[width=0.8\textwidth]{figures/arquitecturaweb.jpg}
		\caption{Arquitectura de una aplicación web}
		\label{fig.arquitecturaweb}
		\end{center}
\end{figure}

\subsection{Tecnologías del lado del cliente}
Estas tecnologías son las encargadas de dar forma a la interfaz de usuario y de establecer la comunicación con el servidor. El navegador es capaz de leer e interpretar estas tecnologías. Las más utilizadas son las siguientes:
\begin{itemize}
	\item Hyper-Text Markup Lenguage (HTML): Es el lenguaje de descripción de aplicaciones web que nos permite especificar las características visuales.
	\item Hojas de estilo en cascada (CSS): Es el lenguaje utilizado para describir la presentación semántica (el aspecto y el formato) de un documento en lenguaje de marcas.
	\item JavaScript: Es un lenguaje de script orientado a objetos y guiado por eventos que nos permiten realizar acciones en el cliente e interactuar con el servidor u otras aplicaciones we.
\end{itemize}

\subsection{Tecnologías del lado del servidor}
Estas tecnologías son las encargadas de dar forma al servidor web de manera que permita el acceso a bases de datos, conexiones de red, recursos compartidos, en definitiva, se encarga de realizar todas las tareas necesarias para crear la aplicación web que se visualizara en el cliente. Las tecnologías más utilizadas son las siguientes:
\begin{itemize}
	\item Common Gatewey Interface (CGI): Fue de las primeras tecnologías del lado del servidor en aparecer, se creó inicialmente para gestionar formularios. No se trata de un lenguaje de programación sino  de un mecanismo de comunicación entre el cliente y un programa externo, que proporcionara el contenido de la aplicación web. Actualmente se utiliza una variante llamada Fast-CGI que proporciona una mayor rapidez.
	\item PHP: Creado en 1994, es la tecnología más utilizada. Se trata de un lenguaje de programación de uso general de script que originalmente fue diseñado para proporcionar contenido web dinámico. Su código esta empotrado en el código HTML y es interpretado por un servidor web para generar la aplicación web, evitando la necesidad de acceder a un archivo externo.
	\item Servlets: Son programas escritos en Java que se ejecutan sobre un servidor de aplicaciones mediante la maquina virtual de Java (JVM). Estos programas (servlets) son ejecutados por el servidor para manejar cada una de las peticiones del cliente. Se trata de una tecnología con un concepto similar a CGI, pero beneficiandose de las ventajas de el entorno Java.
	\item JavaServer Pages (JSP):Se trata de una tecnología Java que permite generar contenido web dinámico en forma de documentos HTML. El código Java, a diferencia que en los Servlets, va incrustado en el HTML y se compila dinámicamente como un servlet.
	\item Active Server Page (ASP): Creado por Microsoft en 1996. Se trata de código que se ejecuta en el servidor y genera un archivo HTML que devuelve al cliente. Al ser una tecnología creada por Microsoft, permite la compatibilidad con componentes ActiveX (acceso a base de datos, scripts, etc) lo que proporciona una gran potencia y flexibilidad. Esta tecnología solo puede ser utilizada en servidores con sistemas operativos de Microsoft.
	\item Python, Django: Se trata de un framework programado en Python que proporciona un conjunto de componentes en el lado del servidor para ayudar a la hora de desarrollar una aplicación web. Sigue el diseño de Modelo-Vista-Controlador, que se trata de un modelo que separa la lógica y datos de la interfaz gráfica y de las comunicaciones y eventos. Cuando un cliente solicita una URL al servidor, esta paso por Django que analizara la URL solicitada y pasara la petición a la función correspondiente llamada vista. En esta función se ejecutara lo necesario para proporcionar al cliente lo solicitado con su URL.
	\item Ruby on Rails: Al igual que Django, Ruby on Rails se trata de un framework para facilitar el desarrollador web programado en Ruby que sigue el diseño de Modelo-Vista-Controlador. El funcionamiento de Django y Rails es muy similar, siendo la principal diferencia el lenguaje en el que están programados, siendo necesario menos código en el caso de Rails.
	\item Node.js: Se trata de un entorno de ejecución multiplataforma de código abierto para el lado del servidor basandose en el lenguaje JavaScript. Este entorno se basa en eventos y gestiona todas las operaciones con una programación asíncrona. Todo esto facilita el desarrollo de aplicaciones web escalables de manera sencilla y con robustas.
\end{itemize}

\section{Robotica}
\subsection{Introducción}
El diccionario de la Real Academia Española define robótica como la técnica que aplica la informática al diseño y empleo de aparatos que, en sustitución de personas, realizan operaciones o trabajos, por lo general en instalaciones industriales. El termino robótica proviene del escritor y profesor de bioquímica Isaac Asimov, quien, en su Saga de la Fundación, definió las leyes de la robótica:
\begin{itemize}
	\item Primera ley: Un robot no puede hacer daño a un ser humano ni, por inacción, permitir que un ser humano sufra daño.
	\item Segunda ley: Un robot debe obedecer las órdenes dadas por los seres humanos, excepto cuando estas entren en conflicto con la primera ley.
	\item Tercera ley: Un robot debe proteger su propia integridad, siempre y cuando esto no impida el cumplimiento de la primera y segunda ley.
\end{itemize}
Desde que Asimov acuñara estas tres leyes, la sociedad a temido lo que los robot puedan hacer al ser humano, desde esclavizarnos hasta quitarnos el trabajo, siendo este miedo el más reciente y el que ha supuesto un mayor freno al desarrollo. Sin embargo, con el paso del tiempo, nos hemos dado cuenta que la robótica tiene una gran utilidad para hacer avanzar la sociedad. Ya no solo pensamos en robótica como en un humanoide que pueda remplazar al ser humano como nos muestran tantas obras literarias y cinematográficas, sino que vemos robótica a lo largo de nuestro día a días, desde un brazo mecánico en una cadena de montaje, hasta un aspirador robótico. Gracias a la robótica, tareas hasta hoy conllevaban riesgos para la salud humana como la desactivación de artefactos explosivos o trabajos con altas temperaturas, o tareas pesadas y repetitivas se pueden realizar de manera más eficiente y fácil gracias a la robotización de las mismas.

Todo robot debe tener una parte hardware (el componente robótico ya sea real o simulado) y una parte software (la lógica de ese componente robótico).

\subsection{Softwares para el desarrollo de componentes robóticos}

El software es el encargado de proporcionar al robot la inteligencia y autonomía necesaria para que realice las funciones o acciones que deseamos. Para facilitar esta tarea, sean creado middleware y bibliotecas especificas.

\subsubsection{Middleware}

Un robot es un sistema complejo ya que es un conjunto de diferentes componentes hardware y software (sensores, actuadores, etc). Para cada robot, sería necesario un software personalizado que sea capaz de: leer y extraer la información necesaria de cada uno de los sensores, calcular y enviar las secuencias de acciones para que realice una determinada tarea o acción, controlar los actuadores, etc. Desarrollar este software se vuelve una tarea compleja e inútil dado que por lo general, si cambiáramos de robot este software no funcionaría de manera correcta.
En este escenario es donde un middleware nos proporcionara las herramientas que necesitamos para facilitar en gran medida la labor, ya que nos permitirá estructurar el software separando las diferentes tares (lectura de sensores, extracción de datos, especificar la velocidad, etc) y haciendo exportable el uso de este software con cualquier otro sistema robótico al tener un marco común de comunicación gracias al middleware.
Actualmente hay una gran cantidad de middleware que permiten esta abstracción, siendo algunos de los más destacados los que señalo a continuación:
\begin{itemize}
	\item Robot Operating System (ROS)\footnote{\url{http://www.ros.org/}}: Pese a ser un middleware, se podría decir que ROS pretende ser algo más. Nos provee de la funcionalidad que cabría esperar de un sistema operativo (abstracción del harware, control de dispositivos de bajo nivel, la trasferencia de mensajes entre procesos, administración de paquetes, etc). El principal objetivo es permitir la reutilización del código en la investigación y desarrollo de robótica, lanzando paquetes de software que están listos para ser usados por cualquier desarrollador. ROS cuenta con una gran comunidad de colaboradores, que comparten sus paquetes y proyectos, gracias a su sitio web y repositorios.
	\item Internet Communication Engine (ICE) \footnote{\url{https://zeroc.com/}}: Creado por la empresa ZeroC, se trata de un middleware orientado a objetos que permite la creación de aplicaciones multilenguaje y multiplataforma, permitiendo la comunicación con diferentes arquitecturas de red (UDP, TCP, WebSockets, etc). ICE no es un middleware robótico propiamente dicho, pero su uso facilita el desarrollo de la conectividad con sistemas robóticos, al permitirnos crear nuestras propias interfaces para el intercambio de datos.
	\item Open Robot Control Software project (Orocos) \footnote{\url{http://www.orocos.org/}}: Se trata de un proyecto de software libre cuyo objetivo es la creación de un paquete de software para el control de robots.
	\item Orca \footnote{\url{https://www.orcaconfig.com/}}: Se trata de un middleware de código libre que se originó a partir del proyecto Orocos. Orca está diseñado para desarrollar sistemas robóticos basados en componentes. Su principal objetivo es permitir, facilitar y simplificar la reutilización del código entre desarrolladores.
	\item Middleware for Robots (Miro): Se trata de un middleware orientado a objetos para el control de robots móviles, y basado en CORBA (Common Object Request Broker Architecture). El hecho de que sea orientado a objetos permite la interoperabilidad entre procesos y plataformas cruzadas para el control de robots distribuidos.
	\item JdeRobot \footnote{\url{https://jderobot.org/}}: Se trata de una plataforma de código abierto para el desarrollo de aplicaciones de visión artificial y robóticas, compatible con middlewares de comunicación ICE y ROS y desarrolladas principalmente en Python y C++.
\end{itemize}

\subsubsection{Bibliotecas}

En programación, una biblioteca es una colección de recursos utilizados para el desarrollo de software. Hay multitud de bibliotecas para el desarrollo de sistemas robóticos: bibliotecas para para procesar imágenes, interactuar con el robot, procesar elementos 3D, etc. Las bibliotecas más utilizadas son:
\begin{itemize}
	\item OpenCV \footnote{\url{https://opencv.org/}}: Es la biblioteca de visión artificial por excelencia. Creada originalmente por Intel, es de código abierto y desarrollada en C++. Actualmente dispone de interfaces en C++, C, Python, Java y están empezando a desarrollar para JavaScript.
	\item Point Cloud Library (PCL) \footnote{\url{http://pointclouds.org/}}: Se trata de una biblioteca de código abierto que proporciona algoritmos para el procesamiento de nubes de puntos y geometría 3D.
	\item Bibliotecas de ROS: ROS proporciona bibliotecas para cada lenguaje de programación al que da soporte, ofreciendo una serie de funciones y algoritmos que nos permite crear aplicaciones que interactúan rápidamente con ROS. Las bibliotecas más utilizadas son rospy \footnote{\url{http://wiki.ros.org/rospy}}, que está desarrollada para Python y roscpp \footnote{\url{http://wiki.ros.org/roscpp}}, que está desarrollada para ser usada con C++. Cabe destacada, también, la biblioteca roslibjs, que ofrece las funcionalidades para JavaScript.
\end{itemize}

\subsubsection{Simuladores}

Un simulador robótico nos permite imitar el funcionamiento de un sistema robótico para poder probar las aplicaciones, evitando que surjan fallos críticos a la hora de hacerlo funcionar con el sistema real. Estos fallos pueden conllevar averías muy costosas a nivel monetario y de tiempo, que conllevarían retrasos importantes a la hora de realizar el desarrollo. Los simuladores más utilizados son:
\begin{itemize}
	\item Gazebo \footnote{\url{http://gazebosim.org/}}: Se trata de uno de los simuladores más utilizados en la actualizada gracias a su fácil manejo y su intuitiva interface. Gazebo es un simulador de código abierto que ofrece múltiples motores de físicas, motores de renderizado avanzado, soporte para plugins y programación en la nube. Además, dispone de un gran número de robots, sensores y cámaras para simular, lo que permite realizar las pruebas de nuestras aplicaciones de forma bastante realista y, así poder utilizar nuestra aplicación con el sistema físico sin miedo a que sufra daños.
	\item ROS Development Studio (RDS \footnote{\url{http://www.theconstructsim.com/}}): Elaborado por la empresa española TheConstruct, se trata de un simulador web que permite simulador sistemas robóticos, a la vez que ofrece un editor y una consola para poder crear nuestro código, pero únicamente ofrece soporte para Python gracias a Jupyter. La gran ventaja que ofrece este simulador es que no es necesario realizar ninguna instalación, simplemente registrarte en su página web y acceder con un navegador. Ofrecen desde una versión básica gratuita hasta una versión para expertos con una tarifa mensual.
\end{itemize}
Existen otros simuladores como son Stage para la simulación en 2D o  Webots, pero no tan utilizados como Gazebo o sin las ventajas de RDS.

\section{Tecnologías web en robótica}

\subsection{Introducción}

La utilización de tecnologías web en robótica es aún, pese a su aumento en los últimos tiempos, un campo con poco desarrollo. Sin embargo, debido a las ventajas que ofrece frente a otras tecnologías (el mismo código funciona en cualquier plataforma, no es necesario realizar ninguna instalación, etc) es un campo prometedor de cara al futuro.

Como he mencionado anteriormente, aún no hay muchos desarrollos basados en tecnologías web, siendo el más importante de ellos las bibliotecas y herramientas de código abierto para su utilización con el middleware ROS, elaboradas por la comunidad de Robot Web Tools \footnote{\url{http://robotwebtools.org/}}.
Los desarrollos más importantes que han realizado son:
\begin{itemize}
	\item Rosbridge Suite: Proporciona una interfaz usando JSON para ROS que permite a cualquier cliente enviar JSON para conectarnos con el robot, mediante las capas de comunicación WebSockets, UDP y TCP. Realmente podría entenderse como un servidor intermedio que recibe o envía la información a un cliente web.
	\item roslibjs: Se trata de la biblioteca que da soporte a la interactuación entre una aplicación web desarrollada en JavaScript con ROS. 
	\item ros2djs y ros3djs: Son las bibliotecas elaboradas para gestionar la visualización de elementos en dos y tres dimensiones, respectivamente. Están elaboradas utilizando roslibjs y proporcionan funciones que son estándares en ROS como la elaboración de mapas, el procesado de nubes de puntos o del escaneo laser.
\end{itemize}

Adicionalmente ofrecen una serie de herramientas como son un servidor de video web, una herramienta para mostrar e interactuar con la navegación autónoma del robot, una herramienta para la creación de teleoperadores de robots, etc.

\subsection{Trabajos Previos}
Este proyecto está basado en el TFG elaborado por Aitor Martinez \footnote{\url{https://jderobot.org/Aitormf-tfg}}. En este trabajó, utilizando tecnologías web, creo tres aplicaciones que eran capaces de conectarse con varios sistemas robóticos.

\subsubsection{CameraViewjs}

Se trata de un visualizador de imágenes, desarrollado utilizando JavaScript, HTML5 y CSS3 en el lado del Cliente y NodeJS en el lado del servidor, e ICE como middleware. Esta aplicación permite la visualización de las imágenes recibidas desde un servidor de imágenes, ya sean obtenidas desde una webcam, una cámara conectada a un robot o almacenadas en el dispositivo.

\begin{figure}[H]
  \begin{center}
    \includegraphics[width=0.8\textwidth]{figures/cameraviewjs.png}
		\caption{CameraViewjs}
		\label{fig.cameraviewjs}
		\end{center}
\end{figure}

\subsubsection{KobukiViewerjs}

Se trata de un visualizador y teleoperador de robots del tipo Turtlebot, desarrollado utilizando JavaScript, HTML5 y CSS3 en el lado del Cliente y NodeJS en el lado del servidor, e ICE como middleware. Consta de varias partes, la primera de ellas es mostrar las imágenes obtenida a través de las dos cámaras de las que dispone el robot (izquierda y derecha), otra parte donde muestra la imagen del escaneo laser obtenida, una representación tridimensional del robot y el movimiento del mismo, y por último, el teleoperador, que envía al robot una velocidad lineal y otra angular para indicar tanto el movimiento en linear recta como la orientación del mismo.

\begin{figure}[H]
  \begin{center}
    \includegraphics[width=0.8\textwidth]{figures/kobukiviewerjs.png}
		\caption{KobukiViewerjs}
		\label{fig.kobukiviewerjs}
		\end{center}
\end{figure}

\subsubsection{UavViewerjs}

Se trata de un visualizador y teleoperador de drones, desarrollado utilizando JavaScript, HTML5 y CSS3 en el lado del Cliente y NodeJS en el lado del servidor, e ICE como middleware. La aplicación tiene integrada sobre la misma pantalla el teleoperador y la imagen obtenida de la cámara, pudiéndose elegir si deseamos mostrar la cámara frontal o de abajo del dron. Consta también de una representación tridimensional del dron y de su movimiento. Desde la aplicación se teleopera mediante él envió de una velocidad lineal y otra angular, además se le indica cuando se desea aterrizar y despegar.

\begin{figure}[H]
  \begin{center}
    \includegraphics[width=0.8\textwidth]{figures/uavviewerjs.png}
		\caption{UavViewerjs}
		\label{fig.uavviewerjs}
		\end{center}
\end{figure}